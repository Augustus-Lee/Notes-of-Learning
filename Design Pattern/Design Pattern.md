## 设计模式

设计模式分为创建型模式，结构型模式，行为型模式。

### 一、创建型模式

>包含**简单工厂模式（GOF23种设计模式中不包含），工厂方法模式，抽象工厂模式，建造者模式，原型模式，单例模式**六种模式。
>
>创建型模式**对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离**。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

##### 1.简单工厂模式(Simple Factory Pattern)

又称为静态工厂方法模式。在简单工厂模式中，**可以根据参数的不同返回不同类的实例**。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

1. 模式结构：

- Factory：工厂角色
    - **工厂角色负责实现创建所有实例的内部逻辑。**
- Product：抽象产品角色
    - 是创建所有对象的父类，负责描述所有实例所共有的**公共接口**。
- ConcreteProduct：具体产品角色
    - 是角色创建目标，所有创建的对象都充当这个角色的某个具体类的实现。

2. 优缺点

- 优点：
    - 将对象的创建和对象处理分离，降低系统的耦合度
    - 只需要传入正确的参数，就可以获取所需的对象，无需知道创建细节
- 缺点：
    - 系统扩展困难，一旦添加新产品时就需要修改工厂类，违背了开闭原则。
    - 由于工厂类集中了所有产品创建逻辑，一旦出现问题，整个系统都会受影响。

3. 适用环境

- 工厂类负责**创建的对象比较少**：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

##### 2.工厂方法模式(Factory Method)

又称为工厂模式，是简单工厂的进一步抽象和推广，它属于类创建型模式。在工厂方法模式中，**工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象**，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

1. 模式结构：
    - Product：抽象产品
    - ConcreteProduct：具体产品
    - Factory：抽象工厂
    - ConcreteFactory：具体工厂
2. 优缺点
    - 优点
        - 增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性。克服了简单工厂的缺点，系统的扩展性较好，符合“开闭原则”。
        - 定义创建对象的接口，封装了对象的创建; 使得具体化类的工作延迟到了子类中。
    - 缺点
        - 添加新产品时，需要创建具体的工厂了和产品类，增加了系统的复杂度，带来了额外开销。
3. 适用环境
    - 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。

##### 3.抽象工厂模式(Abstract Factory)

提供创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

**产品等级结构**：**产品等级结构即产品的继承结构。**如抽象类是电视机，则子类是小米电视机，创维电视机等等，抽象电视机与具体品牌形成了产品等级结构。

**产品族**：在抽象工厂模式中，**产品族是指由用一个工厂生产，位于不同产品等级结构中的一组产品**。例如小米工厂生产的小米手机，电视机。

1. 模式结构
    - AbstractProduct：抽象产品
    - ConcreteProduct：具体产品
    - AbstractFactory：抽象工厂
    - ConcreteFactory：具体工厂
2. 优缺点
    - 优点
        - 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。
        - 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。
    - 缺点
        - 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品。
3. 适用环境
    - AbstractFactory 模式是为**创建一组(有多类)**相关或依赖的对象提 供创建接口，而 Factory 模式正如我在相应的文档中分析的是**为一类对象**提供创建接口或延 迟对象的创建到子类中实现。

##### 4.单例模式(Singleton)

单例模式**确保某一个类只有一个实例**，且自行实例化向整个系统提供这个实例，它提供全局访问的方法。

1. 模式分析
    - 单例类提供一个私有构造函数，确保用户无法通过new关键字直接实例化它
    - 提供一个自身的静态私有成员变量
    - 提供一个公有的静态工厂方法
2. 优缺点
    - 优点
        - 只存在一个对象，节约系统资源
        - 提供了对唯一实例的受控访问，并提供了共享的概念
    - 缺点
        - 单例模式中没有抽象层，导致扩展困难
        - 单例类职责过重，一定程度上违反“单一职责原则”
3. 适用环境
    - 系统只需要一个实例对象，只允许使用一个公共访问点时
    - 如果一个类需要几个实例共存，就对对单例模式进行改进，变成多例模式



### 二、结构型模式

### 三、行为型模式

>行为型模式是**对在不同的对象之间划分责任和算法的抽象化**。
>
>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用
>
>行为型模式分为类行为模式和对象行为型模式：
>
>类行为型模式：类的行为型模式**使用继承关系**在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类和子类的职责
>
>对象行为型模式：对象的行为型模式则使用**对象的聚合关联关系**来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责

#### 1.观察者模式

**定义对象间的一种一对多依赖关系**，使得每当一个对象状态发生改变时，其相关依赖对象皆**得到通知并被自动更新**。此外，发生改变的对象称为观察目标（发布者），而被通知的对象称为观察者（订阅者）**。观察模式是一种对象行为型模式**

1. 模式结构
    - Subject：目标
    - ConcreteSubject：具体目标
    - Observer：观察者
    - ConcreteObserve：具体观察者
2. 模式分析
    - 一个观察目标可以有任意个观察者，一个目标可以有任意数目的与之相依赖的观察者
    - 作为对这个通知的响应，每个观察者都将及时封信自己的状态，与目标状态同步
3. 优缺点
    - 优点
        - 观察者模式支持广播通信，并且符合“开闭原则”
        - 可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制
    - 缺点
        - 如果一个目标有很多观察者的话，通知耗费的时间较多
        - 通知观察者的顺序是随机的

#### 2.命令模式



1. 

#### 3.策略模式

























