### 设计模式

设计模式分为创建型模式，结构型模式，行为型模式。

#### 一、创建型模式

>包含**简单工厂模式（GOF23种设计模式中不包含），工厂方法模式，抽象工厂模式，建造者模式，原型模式，单例模式**六种模式。
>
>创建型模式**对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离**。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

##### 1.简单工厂模式

又称为静态工厂方法模式。在简单工厂模式中，**可以根据参数的不同返回不同类的实例**。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

1. 模式结构：

- Factory：工厂角色
    - **工厂角色负责实现创建所有实例的内部逻辑。**
- Product：抽象产品角色
    - 是创建所有对象的父类，负责描述所有实例所共有的**公共接口**。
- ConcreteProduct：具体产品角色
    - 是角色创建目标，所有创建的对象都充当这个角色的某个具体类的实现。

2. 优缺点

- 优点：
    - 将对象的创建和对象处理分离，降低系统的耦合度
    - 只需要传入正确的参数，就可以获取所需的对象，无需知道创建细节
- 缺点：
    - 系统扩展困难，一旦添加新产品时就需要修改工厂类，违背了开闭原则。
    - 由于工厂类集中了所有产品创建逻辑，一旦出现问题，整个系统都会受影响。

3. 适用环境

- 工厂类负责**创建的对象比较少**：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

##### 2.工厂方法模式

又称为工厂模式，是简单工厂的进一步抽象和推广，它属于类创建型模式。在工厂方法模式中，**工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象**，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

1. 模式结构：
    - Product：抽象产品
    - ConcreteProduct：具体产品
    - Factory：抽象工厂
    - ConcreteFactory：具体工厂
2. 优缺点
    - 优点
        - 增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性。克服了简单工厂的缺点，系统的扩展性较好，符合“开闭原则”。
        - 定义创建对象的接口，封装了对象的创建; 使得具体化类的工作延迟到了子类中。
    - 缺点
        - 添加新产品时，需要创建具体的工厂了和产品类，增加了系统的复杂度，带来了额外开销。
3. 适用环境
    - 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。

##### 3.抽象工厂模式

提供创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

**产品等级结构**：**产品等级结构即产品的继承结构。**如抽象类是电视机，则子类是小米电视机，创维电视机等等，抽象电视机与具体品牌形成了产品等级结构。

**产品族**：在抽象工厂模式中，**产品族是指由用一个工厂生产，位于不同产品等级结构中的一组产品**。例如小米工厂生产的小米手机，电视机。

1. 模式结构
    - AbstractProduct：抽象产品
    - ConcreteProduct：具体产品
    - AbstractFactory：抽象工厂
    - ConcreteFactory：具体工厂
2. 优缺点
    - 优点
        - 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。
        - 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。
    - 缺点
        - 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品。
3. 适用环境
    - AbstractFactory 模式是为**创建一组(有多类)**相关或依赖的对象提 供创建接口，而 Factory 模式正如我在相应的文档中分析的是**为一类对象**提供创建接口或延 迟对象的创建到子类中实现。

##### 4.单例模式























