1. 单引号'A'代表整数65，即ASCII码的位置，双引号"A"即为字符A，后面末尾默认增加"\0"转义字符。

2. **内联函数（inline）**和普通函数相比可加快程序运行速度，因为不需要中断调用，在编译时内联函数可直接被嵌入到目标代码中。而宏（define）只是一个简单替换。

   - 内联函数要做类型检查，宏没有。

   - define是在预处理阶段完成；inline在编译阶段。

   - 内联函数一般用于：一个函数不断被重复调用；函数只有简单的几行，且函数内不包含for，switch，while等语句。

3. - define为文本替换，const为常量值。

   - const在编译阶段使用，define在预处理阶段展开。
   - const有数据类型，有类型安全检查，define无数据类型，无安全检查。
   - 可以对const常量进行调试，而宏常量不能进行调试。
   - const定义的常量在程序运行过程中只有一份拷贝，而 #define定义的常量在内存中有若干个拷贝。const可避免不必要的内存分配，效率更高。

4. C++代码到可执行文件的四个阶段：**预处理阶段 --》编译阶段--》汇编阶段--》链接阶段。**

   - 预处理：***主要处理源文件和头文件中以#开头的命令（#<iostream>等），并删除程序中的注释信息等。***（生成b.i文件）
   - 编译：***将c++代码翻译为汇编代码。***（b.s文件）
   - 汇编：对***汇编代码进行汇编***会生成相应的目标文件（b.o文件二进制文件）。
   - 链接：生成可执行程序b.exe文件。

5. malloc/free与new/delete的区别：

   - malloc/free是C/C++的**标准库函数**，new/delete是C++的**运算符**。都用于动态内存的申请与释放。
   - malloc与free只能用于c语言的动态内存管理，而C++经常调用C函数。
   - malloc是最底层函数，不会调用构造函数，函数返回值是void*， new运算符需要调用构造函数，函数返回相应对象类型的指针。
   - 对象在创建的同时要自动执行构造函数，对象在在消亡之前要自动执行析构函数，不能把自动执行构造函数和析构函数的任务强加于malloc/free。
   - new是类型安全的，malloc不检查。

   ```cpp
   int *p = new int[length];//返回类型是int*,分配的大小是length个。
   
   //返回类型是void*,分配的大小是10。（手动计算字节数）
   int *p = (int *p) malloc(sizeof(int)*10);
   ```

6. static关键字的作用：

   1. 作用域隐藏。当一个工程有多个文件的时候，用static修饰的函数或变量只能在被本文件可以见，文件外不可见。
   2. 全局生命周期。用static修饰的函数或变量生命周期是全局的。存储在静态数据区。
   3. 共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围。
   4. static修饰的变量默认初始化为**0**。
   5. 不能将静态成员函数定义为虚函数。

7. const修饰的成员函数表明不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

8. 平衡二叉树：一种特殊的二叉牌排序树。所有的左右子树的高度之差的绝对值不能超过1。

9. 红黑树：是一种二叉查找树，也是一种弱平衡二叉树，但每个节点增加一个存储位表示节点的颜色，非黑即红。相比较平衡二叉树（AVL树），它的旋转次数更少，插入，删除，搜索频繁的情况下，通常使用红黑树，可以提高效率。**map的底层就是用的红黑树。**

   - 每个节点非黑即红；
   - 根节点是黑的；
   - 每个叶节点都是黑的；
   - 如果一个节点是红的，那么他的子节点必须是黑色的。
   - 对于任意节点来说，到叶子点树NULL指针的每条路径都包含相同数目的黑节点。

10. **平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。**

11. - **size_t是无符号整型类型的别名，和unsigned int有所不同,size_t的取值范围是目标平台下最大可能的数组尺寸。**还可以提高可移植性，可读性和有效性。
    - ***size_t是sizeof运算符返回的类型，在标准库中广泛用于表示大小和计数。***
    
12. ```cpp
    int a[] ={1,2,3,4};
    //数组名a是数组首元素的地址  数组名在某些情况下可以当做指针常量使用，但它并不是指针
    //&a是数组的首地址  
    //首元素的地址与数组地址相同
    cout << a << endl;  		//0x7ffeedbb8a80
    cout << &a << endl;			//0x7ffeedbb8a80
    cout << &a[0] << endl; 	//0x7ffeedbb8a80
    //a + 1为首元素地址 + sizeof(int)的偏移量
    cout << a + 1 << endl;	//0x7ffeedbb8a84
    //&a + 1的偏移量为一个数组的大小 即为 4个int类型元素的大小16字节 转换为16进制
    cout << &a + 1 << endl; //0x7ffeedbb8a90
    
    ```







---

#### Effective C++条款

1. - 带有**多态性性质的的base  classes必须声明一个virtual 析构函数**。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。
    - Classes的设计目的**若不是作为base classes使用，或若不是为了具有多态性**，就不该声明为virtual析构函数。
2. 绝不在**构造函数与析构函数**中调用虚函数。
3. 











