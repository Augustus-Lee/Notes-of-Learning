### 1. C++语言

#### 1.const 关键字的使用场景

1. 阻止一个变量被改变，可使用const，在定义该const变量时，需先初始化；
2. 对指针而言，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
3. 在一个函数声明中，const可以修饰形参表明他是一个输入参数，在函数内部不可以改变其值；
4. 对于类的成员函数，有时候必须指定其为const类型，表明其是一个常函数，不能修改类的成员变量；
5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

#### 2.const与define

1. define为文本替换，const为常量值。
2. const在编译阶段使用，define在预处理阶段展开。
3. const有数据类型，有类型安全检查，define无数据类型，无安全检查。
4. 可以对const常量进行调试，而宏常量不能进行调试。
5. const定义的常量在程序运行过程中只有一份拷贝，而 #define定义的常量在内存中有若干个拷贝。const可避免不必要的内存分配，效率更高。

#### 3.static 关键字的使用场景

1. 全局生命周期。用static修饰的函数或变量生命周期是全局的。存储在静态数据区。
2. 作用域隐藏。当一个工程有多个文件的时候，用static修饰的函数或变量只能在被本文件可以见，文件外不可见。
3. static成员变量，在**类内声明，在类外定义和初始化**，静态成员变量相当于**类域**中全局变量，可以被类的所有对象所共享，包括派生类的对象。**不定义对象，也可以通过类访问静态成员变量**。
4. static成员函数，只能调用**静态成员函数和静态成员变量**，因为静态成员函数没有this指针；静态成员函数不能声明为**virtual,const,volatile**。
5. static修饰的变量默认初始化为**0**。

#### 4.explict 关键字的使用场景

1. 修饰构造函数，防止无预期的类型转换（隐式转换）。

#### 5.volatile 关键字的使用场景

1. volatile关键字是一种类型修饰符，**被修饰的类型变量表示可以被编译期某些未知的因素改变**。
2. 用来解决变量在“共享”环境下容易出现读取错误的问题

#### 6.什么是多态

- 静态多态：发生在编译期：函数重载和模板
- 动态多态：发生在运行期：虚函数

1. 定义：同一个行为，不同实现。**虚函数**是实现多态的前提，多态发生在**继承**中，派生类要对基类的虚函数进行**重写**。
2. 多态用虚函数实现，结合动态绑定。
3. 多态必须是通过**基类的指针或引用来调用虚函数。**

#### 7.虚函数的实现原理

1. 虚函数是通过虚函数表来实现的，**虚函数表**存放了类中所有的的虚函数地址，虚函数表保存在**含有虚函数的类的实例化对象的内存空间中**，**虚函数表的指针存放在对象实例中最前面的位置中**。
2. 虚函数表是一个存储成员函数指针的数据结构；
3. 虚函数表是由编译器自动生成与维护的；
4. virtual成员函数会被编译器放入虚函数表中；
5. 存在虚函数时，每个对象都有一个指向虚函数表的指针（**vptr指针**）
6. 在实现多态的过程中，父类和派生类都有**vptr指针**。

#### 8.构造函数可以是虚函数吗

1. 不可以。构造函数是实例化对象时调用的，如果将构造函数定义为虚函数，而此时**对象并未创建**，则不能调用虚函数，故不能定义成虚函数。（虽然虚函数表在**编译期**就已经存在了，但是虚函数指针存在于对象实例化的内存空间中，故先有了对象才能通过虚函数指针获取虚函数表中的地址进行调用）
2. 从类型上看，构造函数实例化对象时需要明确其类型；而虚函数主要是在信息不全的情况下，能使重写的函数得到调用。
3. 从使用角度来看，构造函数是实例化对象时自动调用；虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用。

#### 9.析构函数可以是虚函数吗，应用场景

- 可以，为了防止**内存泄漏**。因为将基类的指针或引用绑定到派生类的对象，如果未将基类析构函数定义为虚函数，当我们调用析构函数时，那么**只会调用基类析构函数，释放基类的内存空间，派生类的内存空间不会释放**，则会造成内存泄漏。

#### 10.智能指针有哪些，实现原理以及用法

1. 智能指针是为了**解决动态内存分配时造成的内存泄漏以及多次释放同一块内存**。
2. 实现原理：将**基本类型指针封装成类对象指针，在析构函数中调用delete关键字释放内存空间。**
3. auto_ptr在c++11已被弃用。
4. **共享指针（shared_ptr）**：资源可以被**多个指针共享**，使用**计数机制**表明资源被几个指针共享。通过use_count计算使用者的个数，当个数为0时（即没有使用时），则会自动释放内存空间，避免内存泄漏。
5. **独占指针（unique_ptr）**：资源只能被**一个指针占有**，故不支持拷贝构造和赋值操作。
6. **弱指针（weak_ptr）**：指向***shared_ptr指向的对象***，能够解决shared_ptr循环引用的问题。**循环引用：该被调用的析构函数没有被调用，造成了内存的泄漏**

#### 11.什么是模板特化

1. 相对于泛型，指定一个特定的类型。类模板可以**偏特化和全特化，而函数模板只能全特化**。
2. 模板偏特化是根据需要，模板的部分参数特化，而不是全部的参数。模板全特化则为全部参数特化。

#### 12.new 和 malloc 区别

1. malloc/free是C/C++的**标准库函数**（头文件支持），new/delete是C++的**运算符**（编译期支持）。都用于动态内存的申请与释放。
2. malloc是一个最底层的函数，**不会调用构造函数**；new运算符会调用构造函数，函数返回相应类型的指针。
3. new运算符有类型安全检查，malloc不检查。

#### 13.C++ 内存空间布局

1. 堆区：动态申请的内存空间，由mallo分配的内存块，由程序员分配和释放。
2. 栈区：存放函数的**局部变量**，由编译器分配和释放。效率高，但内存容量有限。
3. 自由存储区：和堆十分相似，存放由**new**分配的内存块，由delete释放。
4. 全局区（静态区）：存放全局变量和静态变量。
5. 常量区：存放的时常量，不允许修改。
6. **自由存储区和堆的区别**：
    - 自由存储是C++中通过new和delete动态分配和释放的**抽象概念**，而堆(heap)是操作系统和C语言的术语，是操作系统维护的一块动态分配内存。
    - new申请的内存区域在C++中成为自由存储区。**藉由堆实现的自由存储区**（new的底层实现是调用malloc分配内存），可以说new申请的内存区域在**堆**上
    - ***自由存储区并不等价于堆***，当使用new来分配内存时，可以重载操作符new，**改用其他内存实现自由存储**。

#### 14.如何限制对象只能在**堆上**创建

1. 类对象只能建立在堆上，就**不能静态建立类对象**，故不能直接调用构造函数。
2. 如果将构造函数设为私有，而new运算符建立对象有两个步骤：1.使用malloc分配内存空间 2.调用构造函数初始化。故不能将构造函数设为私有。
3. 当对象在栈上分配空间时，编译器会为对象分配内存空间，调用构造函数。当对象使用完之后，再调用析构函数释放内存。如果**析构函数的访问性是private的，编译器无法调用析构函数，则编译器不会在栈上建立对象**。

#### 15.如何限制对象只能在**栈上**创建

1. 只有使用**new运算符**才会在堆上建立对象，**故禁用new运算符（new调用operaor new函数申请空间），即把operator new()设为私有**。

- 如何让类不能被继承

    1. 使用关键字final可以使得类不被继承
    2. 


#### 16.什么是单例模式，工厂模式

1. 单例模式：创建唯一的一个变量（对象），在类中**将构造函数设为protected或者private（析构函数设为相对应的访问权限），故外部不能实例化对象**，**再提供访问它的一个全局访问点，即定义一个static函数**，返回类中唯一构造的一个实例对象。

    1. 懒汉模式：在系统运行中，实例并不存在，只有**当需要的时候才创建并使用实例**。（**需要考虑线程安全**）可以使用静态局部变量（c++11及以上）

    2. 饿汉模式：指系统一运行，就**初始化创建**实例，当需要的时候，直接调用就行。（本身就是线程安全）
        - 二者的主要区别就是**创建实例的时间**不同
        - 使用懒汉单例时，推荐使用**内部静态变量的懒汉单例，代码量少**。
        - 懒汉式是**空间换时间**，适应于访问量较少；饿汉式是**时间换空间**，适应于访问量较大或者线程较多时。
        - **线程安全**：在拥有**共享资源的多条线程并行执行的程序中**，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

2. 工厂模式：

    1. 功能：1.定义创建对象的接口，封装对象的创建；2.具体化的工作推迟到子类中实现。
    2. **工厂模式的实现方式**分为简单工厂模式，工厂方法模式，抽象工厂模式。
        - 简单工厂模式：一般应用于**多种同类型类的情况，将这些类隐藏起来，再提供统一的接口**，便于维护和修改程序中大部分地方；**根据类型分支选择不同的产品构造函数**。缺点是要求产品的类不多，每增加一个产品类，就要在工厂类增加一个新的分支，违背了**开闭原则**。
            1.  工厂类：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。
            2. 抽象产品类：是具体产品类的继承的父类或实现的接口。
            3. 具体产品类：工厂类所创建的对象就是此具体产品实例。
        - 工厂方法模式：**为解决简单工厂模式违背开闭原则而产生**。**增加对工厂基类的抽象，增加了工厂子类**，使得模式更加有弹性。
            1. 工厂方法模式抽象出了工厂类，提供创建具体产品的接口，交由子类去实现。
        - 抽象工厂模式：工厂方法模式适合**产品种类结构单一**的场合，为一类产品提供创建的接口；而**抽象工厂模式适合产品种类结构多的场合**。当具有多个抽象产品类型时，抽象工厂便可以使用。

#### 17.C++ auto 类型推导的原理

1. 根据初始值value 来推断类型，**auto要求变量必须初始化**，即定义变量的时候的必须赋值；

2. auto类型与初始值类型可能会有出入，**编译器会适当的改变其结果使auto更符合初始化规则**。

    ```cpp
    auto var = value;
    
    const string str01 = "asdad";
    	for (auto  a :str01)//a为char类型
    	{
    		a = '1';//成功赋值  a不是const类型
    	}
    ```

3. decltype也是用于推导类型的，它根据**（表达式）**来推断类型

    ```cpp
    decltype (表达式) var = value;
    //有两个括号，则代表一定是引用类型
    decltype ((int)) var = value;//返回int&
    ```

#### 18.泛型编程如何实现的

1. 泛型即是指在**多种数据类型上**皆可操作，则泛型编程即是不考虑具体类型的一种编程模式。
2. **模板**是实现泛型编程的基础。

#### 19.指针和引用的区别

1. 指针所指的内存空间在运行中是可变的，而引用已经绑定就不可以改变。（是否可变）
2. 指针在内存中占有内存空间的，而**引用是别名**，不具备内存空间。（是否占内存）
3. 指针可以是空指针，而引用必须要绑定对象。（是否为空）
4. 指针是多级的，二级，三级指针；而引用就是别名，不存在多级。（是否多级）

#### 20.动态绑定与静态绑定：

1. 编译期：指**编译器将代码与一些资源文件链接编译成可执行文件这一过程**。
2. 运行期：指**运行编译器生成的可执行文件这一过程**。
3. 对象的静态类型：**对象在声明时采用的类型，是在编译期确定的。**
4. 对象的动态类型：**目前所指对象的类型，是在运行期确定的。对象的动态类型可以更改，对象的静态类型不可更改。**
5. 静态绑定：绑定的是对象的静态类型，发生在**编译期**。
6. 动态绑定：绑定的是对象的动态类型，发生在**运行期**。只有虚函数才会涉及到动态绑定。

#### 21.类型转换：

1. static_cast：**用于转换基础类型和具有继承关系的的对象指针。**static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。
2. dynamic_cast：用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。**适用于多态类之间的类型转换。**
3. const_cast：**用于将const变量转为非const。**
4. reinterpret_cast：强制类型转换。**适用于不同类型的指针类型转换。**

#### 22.野指针

- **野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针**



### 2. 计算机网络

- 三次握手和四次挥手
    1. 三次握手是客户端与服务器建立连接发出的请求，
- TIME_CLOSE 和 TIME_WAIT 的状态和意义
- TCP 如何保证可靠传输
- 流量控制和拥塞控制
    CRC 循环校验的算法
    如何使用 UDP 实现可靠传输
    为什么不能是两次握手
    SYN FLOOD 是什么
    HTTPs 和 HTTP 的区别
    HTTPS 的原理，客户端为什么信任第三方证书
    HTTP 方法了解哪些
    HTTP 异常状态码知道哪些
    HTTP 长连接短连接使用场景是什么
    Arp 攻击
    NAT 原理
    DNS 服务器与提供内容的服务器的区别
    怎么实现 DNS 劫持
    对称加密和非对称的区别，非对称加密有哪些
    AES 的过程
    安全攻击有哪些
    DDOS 有哪些，如何防范
    数据结构
    vector 底层实现
    如何控制 vector 的内存分配
    map, hashmap 底层实现
    map 的 key 如果是结构体需要注意什么问题
    hash冲突如何解决

### 3. 数据库

mysql 索引
B 和 B+ 区别
Redis 的数据结构
Redis持久化
AOF 重写
一致性 Hash
Redis 集群哈希槽
Redis 集群高可用
Redis KEY 过期策略
数据库注入的过程，如何防范



### 4. 操作系统

- 进程和线程的区别

    1. 进程是对**运行时程序的封装**，是**系统进行资源调度和分配的基本单位**，实现了操作系统的并发。
    2. 线程是进程的子任务，是**CPU调度和分派的基本单位**，用于保证程序的实时性，实现进程内部的并发。
    3. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。
    4. 进程在执行过程中有独立的内存单元，而**多个线程共享进程的内存**。
    5. 线程没有独立的地址空间，一旦**有一个线程挂掉将导致进程挂掉**。进程之间是相互独立的，没有影响。

- 进程间的通讯方式

    - 每个进程间有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，故进程间交换数据必须通过内核，在内核中开辟一块缓冲区，**进程A把数据从用户空间拷到内核缓冲区，进程B则从内核缓冲区把数据读走**，**内核提供的这种机制称为进程间通信**。

    - 管道通信(pipe)：

        1. 无名管道通信：管道是一种半双工的通信方式，数据只能**单向流动**，具有固定的读端和写端，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系指的是**父子进程关系**（子进程**完全复制**了父进程的资源，包括堆区，栈区，进程上下文，内存信息等等。父进程利用fork函数创建子进程）

        2. 有名管道通信（FIFO）：具有无名管道的一切性质，且允许**非亲缘关系的进程之间通信。**关联路径名，是一种存在于文件系统中的设备文件。

    - 消息队列：是消息的链接表，存放在内核中。一个消息列表由一个标识符来标记。**消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限的特点**。特点：
        1. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
        2. 消息队列**独立于发送与接收进程**。进程终止时，消息队列及其内容并不会被删除。
        3. 消息队列可以实现消息的随机查询。
    - 信号量(semophore)：信号量是一个**计数器**，可以用来**控制多个进程对共享资源的访问**。信号量用于实现**进程间的互斥和同步**，使得资源在一个时刻只有一个进程独享。
        1. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
        2. 信号量基于操作系统的PV操作，程序对信号量的操作都是**原子操作**（单指令的操作称为原子的，单条指令的执行是不会被打断的）。
        3. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
        4. 支持信号量组。
    - 信号(signal)：是一种比较复杂的通信方式，用于**通知接收进程某个时间已经发生**。
    - 共享内存：指两个以上进程共享一个给定的存储区。
        1. 共享内存是最快的一种IPC(inter-process communication)，因为进程是直接对内存进行存取。
        2. 因为多个进程可以同时操作，故需要同步。
        3. 信号量和共享内存通常结合使用，信号量用来同步对共享内存的访问。
    - 套接字Socket：用于**不同主机间的进程通信**。

- 线程通信：多个线程在处理同一个资源，并且任务不同时，需要线程通信来解决**线程之间对于同一变量的使用或操作，即避免对同一共享变量的争夺**。

    1. 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
    2. 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
    3. 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
    4. 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

- 进程切换的上下文细节

    1. **进程上下文**：就是一个进程在执行的时候，CPU中的所有寄存器中的值、进程的状态以及堆栈上的内容。当内核需要切换到另一个进程时，它需要**保存当前进程的所有状态**，即当前进程的进程上下文，当内核切换回来之后，可以继续执行。一个进程上下文可分成三个部分：**用户级上下文、寄存器上下文和系统级上下文**。
        - 用户级上下文:正文、数据、用户堆栈以及共享存储区；
        - 寄存器上下文：通用寄存器、程序寄存器、处理状态寄存器、栈指针
        - 系统级上下文：进程控制块，内存管理信息、内核栈。
    2. **中断上下文**：硬件传递过来的这些参数和内核需要保存的一些其他环境。

- 线程切换的上下文细节

- CPU 的最小调度单位

    - 线程

- 多线程同步、多进程通信方式

    - 

- 操作系统的栈和堆的区别

- 用户态和内核态的区别

- 用户态和内核态切换的代价
    fork 的过程
    内存置换算法
    什么是虚拟内存，作用
    Select，poll，epoll的区别
    epoll 的 LT 和 ET 的区别
    什么情况下会发生缺页中断，具体流程
    如何判断逻辑地址是否已经映射在物理地址上了
    页表所在的位置
    环形缓冲区的好处
    动态链接和静态链接
    怎么查看端口号占用情况

### 5. 算法

- 反转链表
    多线程交替打印
    实现单例模式
    最小栈
    给定几十万个ip集合，判断任意一个ip是否属于这个集合
    给定一个字符串，判断该字符串是否是环等的（字符串首位相连，如果能找到一个位置，从这个位置顺时针得到的字符串和逆时针得到的字符串相等，即为环等）
    合并两个排序链表
    快排和归并的复杂度分析
    排序链表
    二叉树中和为某一值的路径
    有事洗牌
    打家劫舍II
    LFU 缓存
    乘积最大子数组
    车队
    用 Rand7() 实现 Rand10()
    大整数加法
    三数之和
    k个不同整数的子数组
    快速查找 IP
    最小的k个数
    二叉搜索树的第k大节点
    数组中的重复数字
    XML 格式解析
    有序数组找到第一个小于0的数和第一个大于0的数
    实现一个 string 类
    实现一个智能指针
    两个排序数组找中位数
    无重复字符的最长字串
    string 转 float



#### CVTE

----

C++ 的三大特性

- 封装、多态、继承

编译器会为一个空类自动生成那些函数

- 构造、拷贝构造、析构

多态的原理

- 一种接口，多种实现
- 虚函数重写、继承、父类指针或引用是实现多态的前提
- 

虚函数的工作原理

- 虚函数会生成一个虚函数表，虚函数表中存的都是类中所有虚函数地址，根据指针的指向来调用虚函数

构造函数可以是虚函数吗，析构函数呢

- 析构函数可以是虚函数，基类的虚函数最好用虚函数，**防止内存泄漏**，
- 构造函数不可以是，实例化对象的时候会自动调用构造函数，而虚函数指针是存在于实例化对象的内存空间中，此时还未生成对象，会产生矛盾。简而言之，先有实例化对象，再通过虚函数指针获取虚函数表中的地址进行调用。

什么是纯虚函数

- virtual function() = 0;
- 具有纯虚函数的类是抽象类，抽象类不可以实例化对象
- 子类继承抽象类，必须重写触怒纯虚函数，否则还是抽象类

虚表指针存放的位置，头部还是尾部
如果多重继承只有一个虚表指针吗
函数模板和类模板的区别
什么是内存泄漏，怎么防止内存泄漏

- 使用完内存之后，没有及时释放
- 使用关键字delete回收内存，再给指针置NULL

智能指针有哪些，以及实现原理

- <shared_ptr>

怎么解决循环引用，weak_ptr 是怎么解决循环引用的
你觉得这些定位开源定位内存泄露的工具是怎么实现的
c++11 nullptr 比 NULL 的优势
什么是类型萃取
c++ 有哪些创建线程的方式
c++ 怎么传递信号
c++ 和 python 的区别
深拷贝和浅拷贝的区别
指针和引用的区别
volatile 有什么作用
C++ 的内存分布
new 和 malloc 的区别
static 的作用
了解哪些设计模式
匿名表达式的具体应用和应用场合
class 和 struct 的区别
为什么有了 class 还保留了 struct
c++ 中如何调用 c 写的函数
extern c 的原理
重写、重载、覆盖的区别
成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）
如何避免编译器进行的隐式类型转换
怎么访问私有函数
左值和右值的区别
空类占多少字节

计算机网络
tcp 和 udp 的区别
如何实现基于 udp 的可靠协议
tcp, udp 是那一层的协议
tcp 怎么保证可靠性
tcp 的停止等待协议是什么
三次握手和四次挥手
可以是两次握手吗
为什么要 timewait，timewait 有什么缺点
滑动窗口的原理
网线断开会发生什么，哪一段会先断开
tcp 最大连接数限制
怎么解决 tcp 粘包问题
流量控制和拥塞控制的区别
为什么有了 mac 地址还需要 ip 地址
Http1.1 和 Http1.0 的区别
URI（统一资源标识符）和URL（统一资源定位符）之间的区别
为什么服务端易受到 SYN 攻击
get 和 post 的区别，get 的长度限制是多少
浏览器打开网站的过程
数据结构
用过哪些 STL 库
map 和 unorderedmap 的底层实现和性能区别
二叉搜索树，平衡二叉树，红黑树的区别
vector 中的扩容原理和具体实现方式
如果让你实现 vector 动态删除然后容量缩小你会如何设计
为什么 stl 里面有 sort 函数 list 里面还要再定义一个 sort
操作系统
select, poll, epoll 的区别
什么是死锁，怎么避免
银行家算法
进程间通信方式有哪些
线程同步的方式
linux 755 指的是什么权限
wine 是使 windows 程序能够在 linux 下使用，你觉得他是怎么解决的
系统调用和函数调用的区别
dll 是什么文件
静态库和动态库的区别
什么情况下会发生 dll 缺失
什么是虚拟内存
一台只有 2G 物理内存的电脑，能否 new 一个 4G 大小的数组
孤儿进程、僵尸进程、守护进程的概念
如何创建守护进程
内核态，用户态的区别
算法
了解过哪些排序算法，在什么场景用什么排序
归并排序的实现原理
环形链表
环形链表II
单例模式线程安全写法
二叉树的镜像
递归和迭代的区别和应用场合
重复的子字符串
两个栈实现队列
合并k个升序链表
二分查找
二叉树的遍历方式有哪些



#### BiliBili

---

C 和 C++ 的区别
指针和引用的区别
malloc 和 new，free 和 delete 的区别
extern C 的作用
常用的容器有哪些
volatile 关键字的作用
有哪几种强制类型转换以及使用场景
c++11 新特性
C++ 20 新特性
C++ 的三大特性
C++的多态实现原理
什么是虚函数
什么是纯虚函数
虚表指针的大小
虚函数表的存放内容
构造函数可以是虚函数吗
析构函数可以是虚函数吗
一个空类会生成哪些函数
左值和右值
什么是智能指针，有哪几种，作用，实现原理
如何避免循环依赖
unique_ptr 中 std::move() 作用
static 关键字的使用
const 关键字的使用
define 和 online 的区别
面向对象的设计原则
C++ 编译过程
函数调用的具体实现
计算机网络
三次握手和四次挥手
四次挥手为什么要有 close_wait 状态
tcp 长时间不断开连接会不会断连
tcp 超时重传机制
tcp 如何保证可靠传输
TCP 和 UDP 的区别
TCP 报文长度字段设置在哪里
哪些协议是 TCP 的，哪些是 UDP 的
UDP 怎么实现可靠传输
HTTP 请求报文结构
http 和 https 的区别
怎么解决粘包问题
拥塞控制
流量控制
拥塞控制和流量控制的区别
如何判断网络拥塞
GET 和 POST 的区别
cookie 和 session 区别
DNS 的原理
数据结构
什么是跳表
一个两层的跳表查询时可以降低倒多大的复杂度
vector 和 list 的区别
vector 的扩容原理
map 底层实现
map 和 unordered_map 的区别
如何计算循环链表的长度
二叉搜索树和平衡二叉树，红黑树的区别
红黑树删除数据是怎么调整的
什么是哈希表，哈希函数，怎么解决冲突
stl sort 函数的实现
数据库
redis 的数据类型
redis 的缓存删除策略
redis 怎么实现的定期删除
mysql 中使用的锁有哪些？什么时候使用行锁，什么时候会使用表锁
mysql 的 binlog 日志什么时候会使用
undo 日志和 redo 日志分别是干嘛的
事务还没执行完数据库挂了，重启的时候会发生什么
数据库的 MVCC 的实现原理
事务隔离级别
操作系统
操作系统分段、分页
定时器的实现
读写锁
如果读写锁占用很长时间，并且后续还有读者不断占用读锁，这就造成了写者饥饿的问题，怎么解决？
自旋锁
乐观锁和悲观锁
select、poll 和 epoll 的区别
为啥 epoll 为啥能突破文件上限大小
水平触发和边缘触发的区别
线程和进程的区别
进程之间的状态转换
如何创建多线程
如何实现线程同步
进程之间的通信方式
什么是协程，什么情况下可以使用协程
了解线程模型吗？用户态的线程怎么和内核态的线程映射的
动态链接和静态链接的区别
如何创建一个守护进程
孤儿进程和僵尸进程
系统是如何检测孤儿进程的
Docker 的优缺点
虚拟内存的实现原理
内存泄漏和内存溢出是指什么，内存溢出有什么危害
算法
二叉树的层序遍历
反转链表
实现 strStr()
快速排序时间复杂度，实现原理
形成三的超大倍数
两数相加
回文链表
二叉树的最近公共祖先