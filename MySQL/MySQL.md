### 1. 关系型数据库与非关系型数据库

- 关系型数据库：Oracle、MySQL等
    1. 优点：易于维护，使用简单，可以直接使用sql语句
    2. 缺点：面对海量数据的高效读写，读写性能差；固定的表结构，灵活性差；
- 非关系型数据库：Redis（Key-Value存储）、列存储数据库HBase
    1. 优点：速度快；扩展性好；容易部署。
    2. 不支持事务、sql语句，不利于对复杂的查询

### 2. 约束

#### 2.1主键约束

- **主键（primary key）**：一列(或一组列)，其值能够**唯一标识表中每一行**。通过给某个字段添加约束，就可以使得该字段不重复且不为空。

- ```sql
    --重复
    mysql> insert into user values('1','张三');
    ERROR 1062 (23000): Duplicate entry '1' for key 'user.PRIMARY'
    
    --不能为空
    mysql> insert into user values(NULL,'Lee');
    ERROR 1048 (23000): Column 'id' cannot be null
    ```

- 联合主键：多个字段都为主键；只要联合的主键值加起来不重复，但任意一个都不能为NULL

#### 2.2自增约束

- ```sql
    -- auto_increment 自增
    mysql> create table user3( id int primary key auto_increment, name varchar(20) );
    Query OK, 0 rows affected (0.03 sec)
    ```

#### 2.3唯一约束

- ```sql
    -- unique  使用alter添加
    mysql> alter table user4 add unique(name);
    Query OK, 0 rows affected (0.12 sec)
    Records: 0  Duplicates: 0  Warnings: 0
    
    --删除 unique
    mysql> alter table user4 drop index name;
    Query OK, 0 rows affected (0.03 sec)
    Records: 0  Duplicates: 0  Warnings: 0
    ```

#### 2.4非空约束

- 修饰的字段不能为空NULL
- not null

#### 2.5默认约束

- 插入字段值的时候没有传值，就会使用默认值;传了值就会使用默认值
- age int default 10 

#### 2.6外键约束

- 涉及到两个表：主表，附表

- **主表中的记录被副表使用，不可以被删除**

- **主表中的没有的数据值，副表中不可以使用**

- ```sql
    mysql> create table classes(
        -> id int primary key,
        -> name varchar(20));
    
    mysql> create table stu(
        -> num int primary key auto_increment,
        -> name varchar(20),
        -> classId int,
        -> foreign key(classId) references classes(id)  --外键
        -> );
    ```



### 3. B树(Balance Tree)和B+树(B+Tree)

#### 3.1 B树(平衡多路查找树) -- m阶：

- 根结点至少有两个子节点，每个节点最多有m个子节点
- 所有节点关键字是按递增次序排列，遵从左小右大规则。
- **非叶子节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（ceil(1.1) = 2）**
- 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null

#### 3.2 B+Tree：B树基础上的优化

1. **非叶子节点只保存键值信息，故非叶子节点保存的关键字大大增加。**B树节点既保存key也保存data
2. **数据记录都存放在叶子节点**
3. **各叶节点指针进行连接，构成一个有序链表**
4. 优点：
    - **B+树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；
    - **B+树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
    - **B+树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

**B树**相对于**B+树**的优点：如果经常访问的**数据离根节点很近**，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。

### 4. 数据库索引

#### 4.1 索引类型

1. 唯一索引：每一个索引对应**唯一的数据记录**
2. 主键索引：**以主键作为索引**
3. 聚集索引：**索引的顺序和数据存储的物理顺序**是相同的。

#### 4.2 聚集索引与非聚集索引

1. 聚集索引：
    1. 表数据按照索引的顺序存储，**索引的顺序和表中记录的物理顺序一致**；
    2. 叶子节点存储了真实的数据行，不再有另外单独的数据页；
    3. 一张表中最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。
2. 非聚集索引：
    1. **索引的逻辑顺序和数据存储的物理顺序无关**；
    2. 叶子节点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。
3. 区别：**索引的顺序不同；叶节点存储的内容不同**。

#### 4.3 唯一索引与主键索引

1. 主键索引只能创建一个，唯一索引可以创建多个；
2. 主键索引列**不能是空值**，唯一索引列可以为空值；
3. **主键索引严格来讲就是表的主键，是一种约束；唯一索引是一种索引，它是一种数据结构**，二者有本质的差别；
4. 主键索引可以作为其他表的外键，而唯一索引不可以；
5. 主键一定会创建一个唯一索引，但有唯一索引的列不一定是主键

#### 4.4 索引优缺点

1. 优点：
    - 加快表的查询速度，加快表之间的连接；
    - 唯一索引保证表中每一行数据的唯一性；
2. 缺点：
    - 占用额外的内存空间，索引的维护和创建需要花费一定的时间；
    - 当表发生改变时，同时也要更新索引；
3. 创建索引的场景：
    - 主键会自动创建唯一索引，因为主键是唯一的，不可以重复；
    - 频繁作为**查询条件**的字段应该建立索引；
    - 查询中排序字段的创建会大大提高索引速度。
4. 不适合闯将索引的场景：
    - **频繁进行更新的字段**，因为更新字段时不单单需要更新记录，还会更新索引，保存索引文件
    - 数据重复且分布平均的字段

#### 4.5 索引底层实现（MySQL采用B+树）

### 5. 数据库事务

- 事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。

- 事务：**具有原子性的一组SQL操作语句，或者说是一个独立的工作单元**；或者说是满足ACID特性的一组操作。

- 一个逻辑工作单元要成为事务，必须满足所谓的**ACID（原子性、一致性、隔离性和持久性）属性**：

    - 原子性：一个事务必须被视为不可分割的最小工作单元，**整个事务的所有操作要么全部提交成功，要么全部失败回滚**，对于一个事务而言，不可以只执行一部分操作；
    - 一致性：**指事务使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。**
    - 隔离性：事务隔离性是指多个事务并发执行时，相互之间无影响；**通常来说，一个事务在完全提交成功之前，对其他事物是不可见的**；
    - 持久性：**一旦事务提交，所做的修改就会永久保存到数据库中**。**就不可以回滚**


#### 5.1 数据库事务隔离

1. 四种隔离级别：

    - **未提交读**：事务中的修改，即使没有提交，其他事务也是可见的。**事务可以读取未提交的数据，也称之为脏读。**实际应用中很少使用。
    - **提交读**：大多数数据库的默认隔离级别为**提交读**（MySQL不是）。**一个事务从开始到提交之前，所作的任何修改对其他事务是不可见的**，有时也称之为不可重复读，因为可能两次相同的查询会得到不同的结果。
        - 区别：不可重复读和脏读的区别是，**脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。**
    - **可重复读（MySQL默认隔离级别）**：解决了脏读的问题；该级别保证了在同一事务中多次读取同样记录的结果是一致的；但无法解决**幻读**。
        - 幻读：某次事务在读取**某个范围**的记录时，另一个事务又在此范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生**幻行**。
    - **可串行化：最高的隔离级别**。它通过强制事务串行执行，则可避免幻读的情况。简单来说，可串行化会在读每一行数据的时候都加锁，所以可能导致大量的超时和锁争用问题。

![SQL隔离级别](/Users/swqt/Desktop/Gus/Programming/img/SQL隔离级别.png)

### 6. 四种连接查询

1. 内连接（inner join / join）：内联查询，就是多张表的数据，通过某个字段相等，查询相关数据（返回有匹配的，可以理解成交集）

    - ```sql
         create table person(
            id int,
            name varchar(20),
            cardID int 
            );
            
         create table card(id int , name varchar(20));
            
        insert into card values(1,'邮政');
        insert into card values(2,'建行');
        insert into card values(3,'工商');
        insert into card values(4,'农业');
        insert into card values(5,'中行');
        
        insert into person values(1,'lee',1);
        insert into person values(2,'zhang',3);
        insert into person values(3,'wang',5);
        insert into person values(3,'xiao',6);
        
        --右连接
        mysql> select * from person right join card on person.cardID = card.id;
        +------+-------+--------+------+--------+
        | id   | name  | cardID | id   | name   |
        +------+-------+--------+------+--------+
        |    1 | lee   |      1 |    1 | 邮政   |
        | NULL | NULL  |   NULL |    2 | 建行   |
        |    2 | zhang |      3 |    3 | 工商   |
        | NULL | NULL  |   NULL |    4 | 农业   |
        |    3 | wang  |      5 |    5 | 中行   |
        +------+-------+--------+------+--------+
        
        
        update user set money = money - 100 where name = 'lee';
        update user set money = money + 100 where name = 'zhang';
        ```

2. 左外连接（left join）：会从左表中返回所有的行，如果在右表中没有，会用NULL填充

3. 右外连接（right join）：会从右表中返回所有的行，如果在左表中没有，会用NULL填充

4. 完全外连接（full join）：只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。（可以理解成并集）



### 7. 封锁类型

#### 7.1 锁

1. 基于锁的属性分类

    - 互斥锁（Exclusive），又称写锁，简称**X锁**；加锁期间其他事务不可以加任何锁。
    - 共享锁（Shared），又称读锁，简称**S锁**;加锁期间其他事务可以读，但不可以写。

2. 基于锁的粒度分类

    - 行锁：顾名思义，锁定行；MySQL的行锁是通过索引加载的，所以行锁是要加在索引响应的行上。**特点：**会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高

    - 表锁：锁定表；**表锁响应的是非索引字段，即全表扫描**。**特点：**不会出现死锁；锁定粒度大，发生锁冲突的概率最高

    - 记录锁（Record Lock）：锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

    - 间隙锁（Gap Lock）：锁定索引之间的间隙，但是不包含索引本身。

        ```sql
        -- eg:当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
        select c from t where c between 10 and 20 for update;
        ```

    - 临键锁（Next-Key Lock）：它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。**左闭右开的区间。**

3. 基于锁的状态分类

    - 意向共享锁
    - 意向排他锁

#### 7.2 状态锁

使用**意向锁**（Intention Locks），允许行锁和表锁共存，可以更容易的支持**多粒度封锁**。
意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来**表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁**。

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。
- 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- 这里的兼容关系是针对**表级锁**，**而表级锁IX锁与行级的X锁兼容**，两个事务可以对两个数据行加 X 锁。

#### 7.3 悲观锁与乐观锁

程序设计上的一种锁，思想上的锁

- 乐观锁：认为一般情况下数据不会造成冲突，所以在数据进行提交更新时才会对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做
- 悲观锁：**认为数据被并发修改的概率比较大，所以需要在修改之前先加锁**，意为先加锁再访问。
- 悲观锁比较适合写入操作比较频繁的场景，依赖数据库锁，效率低；乐观锁比较适合读取操作比较频繁的场景，并未加锁，效率高。

### 8. 封锁协议

#### 8.1 三级封锁协议

1. 一级封锁协议

    >事务T要修改数据A时必须加上X锁，直到T结束才释放锁。
    >
    >可以解决丢失修改问题，因为不能同时有两个事务对同一数据进行修改，那么事务的修改就不会覆盖

2. 二级封锁协议

    >在一级封锁协议上加上事务T在读取数据A时必须加上S锁，读取完方可释放S锁
    >
    >可解决脏读问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不可以读入数据

3. 三级封锁协议

    >在一级封锁协议上加上事务T在读取数据A时必须加上S锁，事务结束后才可以释放S锁
    >
    >可解决不可重复读问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

#### 8.2 两段锁协议

1. 指事务必须分成两个阶段对数据操作，即加锁和解锁。
    - 加锁，也称扩展阶段，**事务可以获得任何数据项上任何类型的锁，但是不能释放锁。**
    - 解锁，也称收缩阶段，**事务可以释放任何数据项上的任何类型的锁，但是不能获得锁。**
2. 可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。
3. 事务遵循**两段锁协议是保证可串行化调度的充分条件**。



### 9. 多版本并发控制

#### 9.1 含义：

- 多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎**实现隔离级别的一种具体方式**，用于实现提交读和可重复读这两种隔离级别。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的**并发访问**，在编程语言中实现事务内存

####  9.2 基本思想

- MVCC每次更新操作都会复制一条新的记录，新纪录的创建时间为当前事务id
- 优势为读不加锁，读写不冲突
- 在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照
- MVCC只在可重复读、已提交读两个隔离级别下工作。

#### 9.3 版本号

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

#### 9.4 Undo日志

1. Undo日志是用于存放数据被修改前的值，**把所有没有COMMIT的事务回滚到事务开始前的状态**；可以使用undo日志来实现回滚操作，保证事务的一致性。

2. **当前读**

    读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，**会对读取的记录进行加锁**

3. **快照读**

    **不加锁**的select操作就是快照读，即不加锁的非阻塞读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制；读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息。

#### 9.5 Redo日志

1. 在回放日志的时候把已经COMMIT的事务重做一遍，对于没有commit的事务按照abort处理，不进行任何操作。

2. 作用

    为了保证数据能正确的**持久化**，在系统出现异常的时候通常会对redo log进行回放，把已经commit的事务进行数据重做。

#### 10. 范式

##### 10.1 第一范式（1NF）

1. 定义：指数据库表的每一列都是**不可分割**的基本数据项。
2. 原子性。 字段不可再分,否则就不是关系数据库;

##### 10.2 第二范式（2NF）

- 基于第一范式，每个非主属性完全依赖于主键
- **完全依赖**：即非主属性不能依赖于主键的部分属性，必须依赖于主键的所有属性。

##### 10.3 第三范式（3NF）

- 基于第二范式，非主属性不传递函数依赖于主键；每列都与主键有**直接关系**，不存在传递依赖。
- 传递依赖：A->B, B->C，故A->为传递依赖

##### 10.4 概念

1. 码（超键）：**唯一标识**一条记录的属性或属性集
2. 候选键（候选码）：能够唯一标识一条记录的**最小属性集**
    - 最小性：任一候选键的**任何真子集**都不能唯一标识一个记录（比如在成绩表中（学号,课程号）是一个候选键，单独的学号，课程号都不能决定一条记录）
    - 候选键是**没有多余属性**的超键
3. 主键：**某个**能够**唯一标识**一条记录的**最小属性集（是从候选码里人为挑选的一条）**
    - 唯一性：一个数据表只能由一个主键
    - 不能为空
4. 非主属性：包含在任一候选码中的属性称主属性。简单来说，**主属性是候选码所有属性的并集**
5. 非主属性：不包含在候选码中的属性称为非主属性。













